// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'split_bill_form_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;


final _privateConstructorUsedError = UnsupportedError('It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SplitBillFormEvent {


@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  splitBill,required TResult Function( int unitConsumed)  unitConsumptionChanged,required TResult Function( double bill)  totalBillChanged,required TResult Function()  addMeter,required TResult Function( Meter meter)  updateMeter,required TResult Function( Meter meter)  deleteMeter,required TResult Function( bool considerMainMeterForRemainingUnits)  considerMainMeterForRemainingUnitsChanged,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  splitBill,TResult? Function( int unitConsumed)?  unitConsumptionChanged,TResult? Function( double bill)?  totalBillChanged,TResult? Function()?  addMeter,TResult? Function( Meter meter)?  updateMeter,TResult? Function( Meter meter)?  deleteMeter,TResult? Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  splitBill,TResult Function( int unitConsumed)?  unitConsumptionChanged,TResult Function( double bill)?  totalBillChanged,TResult Function()?  addMeter,TResult Function( Meter meter)?  updateMeter,TResult Function( Meter meter)?  deleteMeter,TResult Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _SplitBill value)  splitBill,required TResult Function( _UnitConsumptionChanged value)  unitConsumptionChanged,required TResult Function( _TotalBillChanged value)  totalBillChanged,required TResult Function( _AddMeter value)  addMeter,required TResult Function( _UpdateMeter value)  updateMeter,required TResult Function( _DeleteMeter value)  deleteMeter,required TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)  considerMainMeterForRemainingUnitsChanged,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _SplitBill value)?  splitBill,TResult? Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult? Function( _TotalBillChanged value)?  totalBillChanged,TResult? Function( _AddMeter value)?  addMeter,TResult? Function( _UpdateMeter value)?  updateMeter,TResult? Function( _DeleteMeter value)?  deleteMeter,TResult? Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _SplitBill value)?  splitBill,TResult Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult Function( _TotalBillChanged value)?  totalBillChanged,TResult Function( _AddMeter value)?  addMeter,TResult Function( _UpdateMeter value)?  updateMeter,TResult Function( _DeleteMeter value)?  deleteMeter,TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) => throw _privateConstructorUsedError;


}

/// @nodoc
abstract class $SplitBillFormEventCopyWith<$Res>  {
  factory $SplitBillFormEventCopyWith(SplitBillFormEvent value, $Res Function(SplitBillFormEvent) then) = _$SplitBillFormEventCopyWithImpl<$Res, SplitBillFormEvent>;



}

/// @nodoc
class _$SplitBillFormEventCopyWithImpl<$Res,$Val extends SplitBillFormEvent> implements $SplitBillFormEventCopyWith<$Res> {
  _$SplitBillFormEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.


}


/// @nodoc
abstract class _$$SplitBillImplCopyWith<$Res>  {
  factory _$$SplitBillImplCopyWith(_$SplitBillImpl value, $Res Function(_$SplitBillImpl) then) = __$$SplitBillImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$SplitBillImplCopyWithImpl<$Res> extends _$SplitBillFormEventCopyWithImpl<$Res, _$SplitBillImpl> implements _$$SplitBillImplCopyWith<$Res> {
  __$$SplitBillImplCopyWithImpl(_$SplitBillImpl _value, $Res Function(_$SplitBillImpl) _then)
      : super(_value, _then);


/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.



}

/// @nodoc


class _$SplitBillImpl  with DiagnosticableTreeMixin implements _SplitBill {
  const _$SplitBillImpl();

  



@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'SplitBillFormEvent.splitBill()';
}

@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  super.debugFillProperties(properties);
  properties
    ..add(DiagnosticsProperty('type', 'SplitBillFormEvent.splitBill'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$SplitBillImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  splitBill,required TResult Function( int unitConsumed)  unitConsumptionChanged,required TResult Function( double bill)  totalBillChanged,required TResult Function()  addMeter,required TResult Function( Meter meter)  updateMeter,required TResult Function( Meter meter)  deleteMeter,required TResult Function( bool considerMainMeterForRemainingUnits)  considerMainMeterForRemainingUnitsChanged,}) {
  return splitBill();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  splitBill,TResult? Function( int unitConsumed)?  unitConsumptionChanged,TResult? Function( double bill)?  totalBillChanged,TResult? Function()?  addMeter,TResult? Function( Meter meter)?  updateMeter,TResult? Function( Meter meter)?  deleteMeter,TResult? Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,}) {
  return splitBill?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  splitBill,TResult Function( int unitConsumed)?  unitConsumptionChanged,TResult Function( double bill)?  totalBillChanged,TResult Function()?  addMeter,TResult Function( Meter meter)?  updateMeter,TResult Function( Meter meter)?  deleteMeter,TResult Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (splitBill != null) {
    return splitBill();
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _SplitBill value)  splitBill,required TResult Function( _UnitConsumptionChanged value)  unitConsumptionChanged,required TResult Function( _TotalBillChanged value)  totalBillChanged,required TResult Function( _AddMeter value)  addMeter,required TResult Function( _UpdateMeter value)  updateMeter,required TResult Function( _DeleteMeter value)  deleteMeter,required TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)  considerMainMeterForRemainingUnitsChanged,}) {
  return splitBill(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _SplitBill value)?  splitBill,TResult? Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult? Function( _TotalBillChanged value)?  totalBillChanged,TResult? Function( _AddMeter value)?  addMeter,TResult? Function( _UpdateMeter value)?  updateMeter,TResult? Function( _DeleteMeter value)?  deleteMeter,TResult? Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,}) {
  return splitBill?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _SplitBill value)?  splitBill,TResult Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult Function( _TotalBillChanged value)?  totalBillChanged,TResult Function( _AddMeter value)?  addMeter,TResult Function( _UpdateMeter value)?  updateMeter,TResult Function( _DeleteMeter value)?  deleteMeter,TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (splitBill != null) {
    return splitBill(this);
  }
  return orElse();
}

}


abstract class _SplitBill implements SplitBillFormEvent {
  const factory _SplitBill() = _$SplitBillImpl;
  

  



}

/// @nodoc
abstract class _$$UnitConsumptionChangedImplCopyWith<$Res>  {
  factory _$$UnitConsumptionChangedImplCopyWith(_$UnitConsumptionChangedImpl value, $Res Function(_$UnitConsumptionChangedImpl) then) = __$$UnitConsumptionChangedImplCopyWithImpl<$Res>;
@useResult
$Res call({
 int unitConsumed
});



}

/// @nodoc
class __$$UnitConsumptionChangedImplCopyWithImpl<$Res> extends _$SplitBillFormEventCopyWithImpl<$Res, _$UnitConsumptionChangedImpl> implements _$$UnitConsumptionChangedImplCopyWith<$Res> {
  __$$UnitConsumptionChangedImplCopyWithImpl(_$UnitConsumptionChangedImpl _value, $Res Function(_$UnitConsumptionChangedImpl) _then)
      : super(_value, _then);


/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? unitConsumed = null,}) {
  return _then(_$UnitConsumptionChangedImpl(
null == unitConsumed ? _value.unitConsumed : unitConsumed // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class _$UnitConsumptionChangedImpl  with DiagnosticableTreeMixin implements _UnitConsumptionChanged {
  const _$UnitConsumptionChangedImpl(this.unitConsumed);

  

@override final  int unitConsumed;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'SplitBillFormEvent.unitConsumptionChanged(unitConsumed: $unitConsumed)';
}

@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  super.debugFillProperties(properties);
  properties
    ..add(DiagnosticsProperty('type', 'SplitBillFormEvent.unitConsumptionChanged'))
    ..add(DiagnosticsProperty('unitConsumed', unitConsumed));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$UnitConsumptionChangedImpl&&(identical(other.unitConsumed, unitConsumed) || other.unitConsumed == unitConsumed));
}


@override
int get hashCode => Object.hash(runtimeType,unitConsumed);

/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$UnitConsumptionChangedImplCopyWith<_$UnitConsumptionChangedImpl> get copyWith => __$$UnitConsumptionChangedImplCopyWithImpl<_$UnitConsumptionChangedImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  splitBill,required TResult Function( int unitConsumed)  unitConsumptionChanged,required TResult Function( double bill)  totalBillChanged,required TResult Function()  addMeter,required TResult Function( Meter meter)  updateMeter,required TResult Function( Meter meter)  deleteMeter,required TResult Function( bool considerMainMeterForRemainingUnits)  considerMainMeterForRemainingUnitsChanged,}) {
  return unitConsumptionChanged(unitConsumed);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  splitBill,TResult? Function( int unitConsumed)?  unitConsumptionChanged,TResult? Function( double bill)?  totalBillChanged,TResult? Function()?  addMeter,TResult? Function( Meter meter)?  updateMeter,TResult? Function( Meter meter)?  deleteMeter,TResult? Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,}) {
  return unitConsumptionChanged?.call(unitConsumed);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  splitBill,TResult Function( int unitConsumed)?  unitConsumptionChanged,TResult Function( double bill)?  totalBillChanged,TResult Function()?  addMeter,TResult Function( Meter meter)?  updateMeter,TResult Function( Meter meter)?  deleteMeter,TResult Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (unitConsumptionChanged != null) {
    return unitConsumptionChanged(unitConsumed);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _SplitBill value)  splitBill,required TResult Function( _UnitConsumptionChanged value)  unitConsumptionChanged,required TResult Function( _TotalBillChanged value)  totalBillChanged,required TResult Function( _AddMeter value)  addMeter,required TResult Function( _UpdateMeter value)  updateMeter,required TResult Function( _DeleteMeter value)  deleteMeter,required TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)  considerMainMeterForRemainingUnitsChanged,}) {
  return unitConsumptionChanged(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _SplitBill value)?  splitBill,TResult? Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult? Function( _TotalBillChanged value)?  totalBillChanged,TResult? Function( _AddMeter value)?  addMeter,TResult? Function( _UpdateMeter value)?  updateMeter,TResult? Function( _DeleteMeter value)?  deleteMeter,TResult? Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,}) {
  return unitConsumptionChanged?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _SplitBill value)?  splitBill,TResult Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult Function( _TotalBillChanged value)?  totalBillChanged,TResult Function( _AddMeter value)?  addMeter,TResult Function( _UpdateMeter value)?  updateMeter,TResult Function( _DeleteMeter value)?  deleteMeter,TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (unitConsumptionChanged != null) {
    return unitConsumptionChanged(this);
  }
  return orElse();
}

}


abstract class _UnitConsumptionChanged implements SplitBillFormEvent {
  const factory _UnitConsumptionChanged(final  int unitConsumed) = _$UnitConsumptionChangedImpl;
  

  

 int get unitConsumed;
/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
_$$UnitConsumptionChangedImplCopyWith<_$UnitConsumptionChangedImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$TotalBillChangedImplCopyWith<$Res>  {
  factory _$$TotalBillChangedImplCopyWith(_$TotalBillChangedImpl value, $Res Function(_$TotalBillChangedImpl) then) = __$$TotalBillChangedImplCopyWithImpl<$Res>;
@useResult
$Res call({
 double bill
});



}

/// @nodoc
class __$$TotalBillChangedImplCopyWithImpl<$Res> extends _$SplitBillFormEventCopyWithImpl<$Res, _$TotalBillChangedImpl> implements _$$TotalBillChangedImplCopyWith<$Res> {
  __$$TotalBillChangedImplCopyWithImpl(_$TotalBillChangedImpl _value, $Res Function(_$TotalBillChangedImpl) _then)
      : super(_value, _then);


/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? bill = null,}) {
  return _then(_$TotalBillChangedImpl(
null == bill ? _value.bill : bill // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}

/// @nodoc


class _$TotalBillChangedImpl  with DiagnosticableTreeMixin implements _TotalBillChanged {
  const _$TotalBillChangedImpl(this.bill);

  

@override final  double bill;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'SplitBillFormEvent.totalBillChanged(bill: $bill)';
}

@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  super.debugFillProperties(properties);
  properties
    ..add(DiagnosticsProperty('type', 'SplitBillFormEvent.totalBillChanged'))
    ..add(DiagnosticsProperty('bill', bill));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$TotalBillChangedImpl&&(identical(other.bill, bill) || other.bill == bill));
}


@override
int get hashCode => Object.hash(runtimeType,bill);

/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$TotalBillChangedImplCopyWith<_$TotalBillChangedImpl> get copyWith => __$$TotalBillChangedImplCopyWithImpl<_$TotalBillChangedImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  splitBill,required TResult Function( int unitConsumed)  unitConsumptionChanged,required TResult Function( double bill)  totalBillChanged,required TResult Function()  addMeter,required TResult Function( Meter meter)  updateMeter,required TResult Function( Meter meter)  deleteMeter,required TResult Function( bool considerMainMeterForRemainingUnits)  considerMainMeterForRemainingUnitsChanged,}) {
  return totalBillChanged(bill);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  splitBill,TResult? Function( int unitConsumed)?  unitConsumptionChanged,TResult? Function( double bill)?  totalBillChanged,TResult? Function()?  addMeter,TResult? Function( Meter meter)?  updateMeter,TResult? Function( Meter meter)?  deleteMeter,TResult? Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,}) {
  return totalBillChanged?.call(bill);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  splitBill,TResult Function( int unitConsumed)?  unitConsumptionChanged,TResult Function( double bill)?  totalBillChanged,TResult Function()?  addMeter,TResult Function( Meter meter)?  updateMeter,TResult Function( Meter meter)?  deleteMeter,TResult Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (totalBillChanged != null) {
    return totalBillChanged(bill);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _SplitBill value)  splitBill,required TResult Function( _UnitConsumptionChanged value)  unitConsumptionChanged,required TResult Function( _TotalBillChanged value)  totalBillChanged,required TResult Function( _AddMeter value)  addMeter,required TResult Function( _UpdateMeter value)  updateMeter,required TResult Function( _DeleteMeter value)  deleteMeter,required TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)  considerMainMeterForRemainingUnitsChanged,}) {
  return totalBillChanged(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _SplitBill value)?  splitBill,TResult? Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult? Function( _TotalBillChanged value)?  totalBillChanged,TResult? Function( _AddMeter value)?  addMeter,TResult? Function( _UpdateMeter value)?  updateMeter,TResult? Function( _DeleteMeter value)?  deleteMeter,TResult? Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,}) {
  return totalBillChanged?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _SplitBill value)?  splitBill,TResult Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult Function( _TotalBillChanged value)?  totalBillChanged,TResult Function( _AddMeter value)?  addMeter,TResult Function( _UpdateMeter value)?  updateMeter,TResult Function( _DeleteMeter value)?  deleteMeter,TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (totalBillChanged != null) {
    return totalBillChanged(this);
  }
  return orElse();
}

}


abstract class _TotalBillChanged implements SplitBillFormEvent {
  const factory _TotalBillChanged(final  double bill) = _$TotalBillChangedImpl;
  

  

 double get bill;
/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
_$$TotalBillChangedImplCopyWith<_$TotalBillChangedImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$AddMeterImplCopyWith<$Res>  {
  factory _$$AddMeterImplCopyWith(_$AddMeterImpl value, $Res Function(_$AddMeterImpl) then) = __$$AddMeterImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$AddMeterImplCopyWithImpl<$Res> extends _$SplitBillFormEventCopyWithImpl<$Res, _$AddMeterImpl> implements _$$AddMeterImplCopyWith<$Res> {
  __$$AddMeterImplCopyWithImpl(_$AddMeterImpl _value, $Res Function(_$AddMeterImpl) _then)
      : super(_value, _then);


/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.



}

/// @nodoc


class _$AddMeterImpl  with DiagnosticableTreeMixin implements _AddMeter {
  const _$AddMeterImpl();

  



@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'SplitBillFormEvent.addMeter()';
}

@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  super.debugFillProperties(properties);
  properties
    ..add(DiagnosticsProperty('type', 'SplitBillFormEvent.addMeter'))
    ;
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$AddMeterImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  splitBill,required TResult Function( int unitConsumed)  unitConsumptionChanged,required TResult Function( double bill)  totalBillChanged,required TResult Function()  addMeter,required TResult Function( Meter meter)  updateMeter,required TResult Function( Meter meter)  deleteMeter,required TResult Function( bool considerMainMeterForRemainingUnits)  considerMainMeterForRemainingUnitsChanged,}) {
  return addMeter();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  splitBill,TResult? Function( int unitConsumed)?  unitConsumptionChanged,TResult? Function( double bill)?  totalBillChanged,TResult? Function()?  addMeter,TResult? Function( Meter meter)?  updateMeter,TResult? Function( Meter meter)?  deleteMeter,TResult? Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,}) {
  return addMeter?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  splitBill,TResult Function( int unitConsumed)?  unitConsumptionChanged,TResult Function( double bill)?  totalBillChanged,TResult Function()?  addMeter,TResult Function( Meter meter)?  updateMeter,TResult Function( Meter meter)?  deleteMeter,TResult Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (addMeter != null) {
    return addMeter();
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _SplitBill value)  splitBill,required TResult Function( _UnitConsumptionChanged value)  unitConsumptionChanged,required TResult Function( _TotalBillChanged value)  totalBillChanged,required TResult Function( _AddMeter value)  addMeter,required TResult Function( _UpdateMeter value)  updateMeter,required TResult Function( _DeleteMeter value)  deleteMeter,required TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)  considerMainMeterForRemainingUnitsChanged,}) {
  return addMeter(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _SplitBill value)?  splitBill,TResult? Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult? Function( _TotalBillChanged value)?  totalBillChanged,TResult? Function( _AddMeter value)?  addMeter,TResult? Function( _UpdateMeter value)?  updateMeter,TResult? Function( _DeleteMeter value)?  deleteMeter,TResult? Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,}) {
  return addMeter?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _SplitBill value)?  splitBill,TResult Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult Function( _TotalBillChanged value)?  totalBillChanged,TResult Function( _AddMeter value)?  addMeter,TResult Function( _UpdateMeter value)?  updateMeter,TResult Function( _DeleteMeter value)?  deleteMeter,TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (addMeter != null) {
    return addMeter(this);
  }
  return orElse();
}

}


abstract class _AddMeter implements SplitBillFormEvent {
  const factory _AddMeter() = _$AddMeterImpl;
  

  



}

/// @nodoc
abstract class _$$UpdateMeterImplCopyWith<$Res>  {
  factory _$$UpdateMeterImplCopyWith(_$UpdateMeterImpl value, $Res Function(_$UpdateMeterImpl) then) = __$$UpdateMeterImplCopyWithImpl<$Res>;
@useResult
$Res call({
 Meter meter
});


$MeterCopyWith<$Res> get meter;
}

/// @nodoc
class __$$UpdateMeterImplCopyWithImpl<$Res> extends _$SplitBillFormEventCopyWithImpl<$Res, _$UpdateMeterImpl> implements _$$UpdateMeterImplCopyWith<$Res> {
  __$$UpdateMeterImplCopyWithImpl(_$UpdateMeterImpl _value, $Res Function(_$UpdateMeterImpl) _then)
      : super(_value, _then);


/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? meter = null,}) {
  return _then(_$UpdateMeterImpl(
null == meter ? _value.meter : meter // ignore: cast_nullable_to_non_nullable
as Meter,
  ));
}

/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MeterCopyWith<$Res> get meter {
  
  return $MeterCopyWith<$Res>(_value.meter, (value) {
    return _then(_value.copyWith(meter: value) );
  });
}
}

/// @nodoc


class _$UpdateMeterImpl  with DiagnosticableTreeMixin implements _UpdateMeter {
  const _$UpdateMeterImpl(this.meter);

  

@override final  Meter meter;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'SplitBillFormEvent.updateMeter(meter: $meter)';
}

@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  super.debugFillProperties(properties);
  properties
    ..add(DiagnosticsProperty('type', 'SplitBillFormEvent.updateMeter'))
    ..add(DiagnosticsProperty('meter', meter));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$UpdateMeterImpl&&(identical(other.meter, meter) || other.meter == meter));
}


@override
int get hashCode => Object.hash(runtimeType,meter);

/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$UpdateMeterImplCopyWith<_$UpdateMeterImpl> get copyWith => __$$UpdateMeterImplCopyWithImpl<_$UpdateMeterImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  splitBill,required TResult Function( int unitConsumed)  unitConsumptionChanged,required TResult Function( double bill)  totalBillChanged,required TResult Function()  addMeter,required TResult Function( Meter meter)  updateMeter,required TResult Function( Meter meter)  deleteMeter,required TResult Function( bool considerMainMeterForRemainingUnits)  considerMainMeterForRemainingUnitsChanged,}) {
  return updateMeter(meter);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  splitBill,TResult? Function( int unitConsumed)?  unitConsumptionChanged,TResult? Function( double bill)?  totalBillChanged,TResult? Function()?  addMeter,TResult? Function( Meter meter)?  updateMeter,TResult? Function( Meter meter)?  deleteMeter,TResult? Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,}) {
  return updateMeter?.call(meter);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  splitBill,TResult Function( int unitConsumed)?  unitConsumptionChanged,TResult Function( double bill)?  totalBillChanged,TResult Function()?  addMeter,TResult Function( Meter meter)?  updateMeter,TResult Function( Meter meter)?  deleteMeter,TResult Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (updateMeter != null) {
    return updateMeter(meter);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _SplitBill value)  splitBill,required TResult Function( _UnitConsumptionChanged value)  unitConsumptionChanged,required TResult Function( _TotalBillChanged value)  totalBillChanged,required TResult Function( _AddMeter value)  addMeter,required TResult Function( _UpdateMeter value)  updateMeter,required TResult Function( _DeleteMeter value)  deleteMeter,required TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)  considerMainMeterForRemainingUnitsChanged,}) {
  return updateMeter(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _SplitBill value)?  splitBill,TResult? Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult? Function( _TotalBillChanged value)?  totalBillChanged,TResult? Function( _AddMeter value)?  addMeter,TResult? Function( _UpdateMeter value)?  updateMeter,TResult? Function( _DeleteMeter value)?  deleteMeter,TResult? Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,}) {
  return updateMeter?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _SplitBill value)?  splitBill,TResult Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult Function( _TotalBillChanged value)?  totalBillChanged,TResult Function( _AddMeter value)?  addMeter,TResult Function( _UpdateMeter value)?  updateMeter,TResult Function( _DeleteMeter value)?  deleteMeter,TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (updateMeter != null) {
    return updateMeter(this);
  }
  return orElse();
}

}


abstract class _UpdateMeter implements SplitBillFormEvent {
  const factory _UpdateMeter(final  Meter meter) = _$UpdateMeterImpl;
  

  

 Meter get meter;
/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
_$$UpdateMeterImplCopyWith<_$UpdateMeterImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$DeleteMeterImplCopyWith<$Res>  {
  factory _$$DeleteMeterImplCopyWith(_$DeleteMeterImpl value, $Res Function(_$DeleteMeterImpl) then) = __$$DeleteMeterImplCopyWithImpl<$Res>;
@useResult
$Res call({
 Meter meter
});


$MeterCopyWith<$Res> get meter;
}

/// @nodoc
class __$$DeleteMeterImplCopyWithImpl<$Res> extends _$SplitBillFormEventCopyWithImpl<$Res, _$DeleteMeterImpl> implements _$$DeleteMeterImplCopyWith<$Res> {
  __$$DeleteMeterImplCopyWithImpl(_$DeleteMeterImpl _value, $Res Function(_$DeleteMeterImpl) _then)
      : super(_value, _then);


/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? meter = null,}) {
  return _then(_$DeleteMeterImpl(
null == meter ? _value.meter : meter // ignore: cast_nullable_to_non_nullable
as Meter,
  ));
}

/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MeterCopyWith<$Res> get meter {
  
  return $MeterCopyWith<$Res>(_value.meter, (value) {
    return _then(_value.copyWith(meter: value) );
  });
}
}

/// @nodoc


class _$DeleteMeterImpl  with DiagnosticableTreeMixin implements _DeleteMeter {
  const _$DeleteMeterImpl(this.meter);

  

@override final  Meter meter;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'SplitBillFormEvent.deleteMeter(meter: $meter)';
}

@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  super.debugFillProperties(properties);
  properties
    ..add(DiagnosticsProperty('type', 'SplitBillFormEvent.deleteMeter'))
    ..add(DiagnosticsProperty('meter', meter));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$DeleteMeterImpl&&(identical(other.meter, meter) || other.meter == meter));
}


@override
int get hashCode => Object.hash(runtimeType,meter);

/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$DeleteMeterImplCopyWith<_$DeleteMeterImpl> get copyWith => __$$DeleteMeterImplCopyWithImpl<_$DeleteMeterImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  splitBill,required TResult Function( int unitConsumed)  unitConsumptionChanged,required TResult Function( double bill)  totalBillChanged,required TResult Function()  addMeter,required TResult Function( Meter meter)  updateMeter,required TResult Function( Meter meter)  deleteMeter,required TResult Function( bool considerMainMeterForRemainingUnits)  considerMainMeterForRemainingUnitsChanged,}) {
  return deleteMeter(meter);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  splitBill,TResult? Function( int unitConsumed)?  unitConsumptionChanged,TResult? Function( double bill)?  totalBillChanged,TResult? Function()?  addMeter,TResult? Function( Meter meter)?  updateMeter,TResult? Function( Meter meter)?  deleteMeter,TResult? Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,}) {
  return deleteMeter?.call(meter);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  splitBill,TResult Function( int unitConsumed)?  unitConsumptionChanged,TResult Function( double bill)?  totalBillChanged,TResult Function()?  addMeter,TResult Function( Meter meter)?  updateMeter,TResult Function( Meter meter)?  deleteMeter,TResult Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (deleteMeter != null) {
    return deleteMeter(meter);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _SplitBill value)  splitBill,required TResult Function( _UnitConsumptionChanged value)  unitConsumptionChanged,required TResult Function( _TotalBillChanged value)  totalBillChanged,required TResult Function( _AddMeter value)  addMeter,required TResult Function( _UpdateMeter value)  updateMeter,required TResult Function( _DeleteMeter value)  deleteMeter,required TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)  considerMainMeterForRemainingUnitsChanged,}) {
  return deleteMeter(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _SplitBill value)?  splitBill,TResult? Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult? Function( _TotalBillChanged value)?  totalBillChanged,TResult? Function( _AddMeter value)?  addMeter,TResult? Function( _UpdateMeter value)?  updateMeter,TResult? Function( _DeleteMeter value)?  deleteMeter,TResult? Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,}) {
  return deleteMeter?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _SplitBill value)?  splitBill,TResult Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult Function( _TotalBillChanged value)?  totalBillChanged,TResult Function( _AddMeter value)?  addMeter,TResult Function( _UpdateMeter value)?  updateMeter,TResult Function( _DeleteMeter value)?  deleteMeter,TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (deleteMeter != null) {
    return deleteMeter(this);
  }
  return orElse();
}

}


abstract class _DeleteMeter implements SplitBillFormEvent {
  const factory _DeleteMeter(final  Meter meter) = _$DeleteMeterImpl;
  

  

 Meter get meter;
/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
_$$DeleteMeterImplCopyWith<_$DeleteMeterImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWith<$Res>  {
  factory _$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWith(_$ConsiderMainMeterForRemainingUnitsChangedImpl value, $Res Function(_$ConsiderMainMeterForRemainingUnitsChangedImpl) then) = __$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWithImpl<$Res>;
@useResult
$Res call({
 bool considerMainMeterForRemainingUnits
});



}

/// @nodoc
class __$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWithImpl<$Res> extends _$SplitBillFormEventCopyWithImpl<$Res, _$ConsiderMainMeterForRemainingUnitsChangedImpl> implements _$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWith<$Res> {
  __$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWithImpl(_$ConsiderMainMeterForRemainingUnitsChangedImpl _value, $Res Function(_$ConsiderMainMeterForRemainingUnitsChangedImpl) _then)
      : super(_value, _then);


/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? considerMainMeterForRemainingUnits = null,}) {
  return _then(_$ConsiderMainMeterForRemainingUnitsChangedImpl(
null == considerMainMeterForRemainingUnits ? _value.considerMainMeterForRemainingUnits : considerMainMeterForRemainingUnits // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc


class _$ConsiderMainMeterForRemainingUnitsChangedImpl  with DiagnosticableTreeMixin implements _ConsiderMainMeterForRemainingUnitsChanged {
  const _$ConsiderMainMeterForRemainingUnitsChangedImpl(this.considerMainMeterForRemainingUnits);

  

@override final  bool considerMainMeterForRemainingUnits;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'SplitBillFormEvent.considerMainMeterForRemainingUnitsChanged(considerMainMeterForRemainingUnits: $considerMainMeterForRemainingUnits)';
}

@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  super.debugFillProperties(properties);
  properties
    ..add(DiagnosticsProperty('type', 'SplitBillFormEvent.considerMainMeterForRemainingUnitsChanged'))
    ..add(DiagnosticsProperty('considerMainMeterForRemainingUnits', considerMainMeterForRemainingUnits));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$ConsiderMainMeterForRemainingUnitsChangedImpl&&(identical(other.considerMainMeterForRemainingUnits, considerMainMeterForRemainingUnits) || other.considerMainMeterForRemainingUnits == considerMainMeterForRemainingUnits));
}


@override
int get hashCode => Object.hash(runtimeType,considerMainMeterForRemainingUnits);

/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWith<_$ConsiderMainMeterForRemainingUnitsChangedImpl> get copyWith => __$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWithImpl<_$ConsiderMainMeterForRemainingUnitsChangedImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  splitBill,required TResult Function( int unitConsumed)  unitConsumptionChanged,required TResult Function( double bill)  totalBillChanged,required TResult Function()  addMeter,required TResult Function( Meter meter)  updateMeter,required TResult Function( Meter meter)  deleteMeter,required TResult Function( bool considerMainMeterForRemainingUnits)  considerMainMeterForRemainingUnitsChanged,}) {
  return considerMainMeterForRemainingUnitsChanged(considerMainMeterForRemainingUnits);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  splitBill,TResult? Function( int unitConsumed)?  unitConsumptionChanged,TResult? Function( double bill)?  totalBillChanged,TResult? Function()?  addMeter,TResult? Function( Meter meter)?  updateMeter,TResult? Function( Meter meter)?  deleteMeter,TResult? Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,}) {
  return considerMainMeterForRemainingUnitsChanged?.call(considerMainMeterForRemainingUnits);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  splitBill,TResult Function( int unitConsumed)?  unitConsumptionChanged,TResult Function( double bill)?  totalBillChanged,TResult Function()?  addMeter,TResult Function( Meter meter)?  updateMeter,TResult Function( Meter meter)?  deleteMeter,TResult Function( bool considerMainMeterForRemainingUnits)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (considerMainMeterForRemainingUnitsChanged != null) {
    return considerMainMeterForRemainingUnitsChanged(considerMainMeterForRemainingUnits);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _SplitBill value)  splitBill,required TResult Function( _UnitConsumptionChanged value)  unitConsumptionChanged,required TResult Function( _TotalBillChanged value)  totalBillChanged,required TResult Function( _AddMeter value)  addMeter,required TResult Function( _UpdateMeter value)  updateMeter,required TResult Function( _DeleteMeter value)  deleteMeter,required TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)  considerMainMeterForRemainingUnitsChanged,}) {
  return considerMainMeterForRemainingUnitsChanged(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _SplitBill value)?  splitBill,TResult? Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult? Function( _TotalBillChanged value)?  totalBillChanged,TResult? Function( _AddMeter value)?  addMeter,TResult? Function( _UpdateMeter value)?  updateMeter,TResult? Function( _DeleteMeter value)?  deleteMeter,TResult? Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,}) {
  return considerMainMeterForRemainingUnitsChanged?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _SplitBill value)?  splitBill,TResult Function( _UnitConsumptionChanged value)?  unitConsumptionChanged,TResult Function( _TotalBillChanged value)?  totalBillChanged,TResult Function( _AddMeter value)?  addMeter,TResult Function( _UpdateMeter value)?  updateMeter,TResult Function( _DeleteMeter value)?  deleteMeter,TResult Function( _ConsiderMainMeterForRemainingUnitsChanged value)?  considerMainMeterForRemainingUnitsChanged,required TResult orElse(),}) {
  if (considerMainMeterForRemainingUnitsChanged != null) {
    return considerMainMeterForRemainingUnitsChanged(this);
  }
  return orElse();
}

}


abstract class _ConsiderMainMeterForRemainingUnitsChanged implements SplitBillFormEvent {
  const factory _ConsiderMainMeterForRemainingUnitsChanged(final  bool considerMainMeterForRemainingUnits) = _$ConsiderMainMeterForRemainingUnitsChangedImpl;
  

  

 bool get considerMainMeterForRemainingUnits;
/// Create a copy of SplitBillFormEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
_$$ConsiderMainMeterForRemainingUnitsChangedImplCopyWith<_$ConsiderMainMeterForRemainingUnitsChangedImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
mixin _$SplitBillFormState {

 ProcessState get processState => throw _privateConstructorUsedError; int get unitConsumed => throw _privateConstructorUsedError; double get totalBill => throw _privateConstructorUsedError; List<Meter> get meters => throw _privateConstructorUsedError; bool get considerMainMeterForRemainingUnits => throw _privateConstructorUsedError;







/// Create a copy of SplitBillFormState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
$SplitBillFormStateCopyWith<SplitBillFormState> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class $SplitBillFormStateCopyWith<$Res>  {
  factory $SplitBillFormStateCopyWith(SplitBillFormState value, $Res Function(SplitBillFormState) then) = _$SplitBillFormStateCopyWithImpl<$Res, SplitBillFormState>;
@useResult
$Res call({
 ProcessState processState, int unitConsumed, double totalBill, List<Meter> meters, bool considerMainMeterForRemainingUnits
});


$ProcessStateCopyWith<$Res> get processState;
}

/// @nodoc
class _$SplitBillFormStateCopyWithImpl<$Res,$Val extends SplitBillFormState> implements $SplitBillFormStateCopyWith<$Res> {
  _$SplitBillFormStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

/// Create a copy of SplitBillFormState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? processState = null,Object? unitConsumed = null,Object? totalBill = null,Object? meters = null,Object? considerMainMeterForRemainingUnits = null,}) {
  return _then(_value.copyWith(
processState: null == processState ? _value.processState : processState // ignore: cast_nullable_to_non_nullable
as ProcessState,unitConsumed: null == unitConsumed ? _value.unitConsumed : unitConsumed // ignore: cast_nullable_to_non_nullable
as int,totalBill: null == totalBill ? _value.totalBill : totalBill // ignore: cast_nullable_to_non_nullable
as double,meters: null == meters ? _value.meters : meters // ignore: cast_nullable_to_non_nullable
as List<Meter>,considerMainMeterForRemainingUnits: null == considerMainMeterForRemainingUnits ? _value.considerMainMeterForRemainingUnits : considerMainMeterForRemainingUnits // ignore: cast_nullable_to_non_nullable
as bool,
  )as $Val);
}
/// Create a copy of SplitBillFormState
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ProcessStateCopyWith<$Res> get processState {
  
  return $ProcessStateCopyWith<$Res>(_value.processState, (value) {
    return _then(_value.copyWith(processState: value) as $Val);
  });
}
}


/// @nodoc
abstract class _$$SplitBillFormStateImplCopyWith<$Res> implements $SplitBillFormStateCopyWith<$Res> {
  factory _$$SplitBillFormStateImplCopyWith(_$SplitBillFormStateImpl value, $Res Function(_$SplitBillFormStateImpl) then) = __$$SplitBillFormStateImplCopyWithImpl<$Res>;
@override @useResult
$Res call({
 ProcessState processState, int unitConsumed, double totalBill, List<Meter> meters, bool considerMainMeterForRemainingUnits
});


@override $ProcessStateCopyWith<$Res> get processState;
}

/// @nodoc
class __$$SplitBillFormStateImplCopyWithImpl<$Res> extends _$SplitBillFormStateCopyWithImpl<$Res, _$SplitBillFormStateImpl> implements _$$SplitBillFormStateImplCopyWith<$Res> {
  __$$SplitBillFormStateImplCopyWithImpl(_$SplitBillFormStateImpl _value, $Res Function(_$SplitBillFormStateImpl) _then)
      : super(_value, _then);


/// Create a copy of SplitBillFormState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? processState = null,Object? unitConsumed = null,Object? totalBill = null,Object? meters = null,Object? considerMainMeterForRemainingUnits = null,}) {
  return _then(_$SplitBillFormStateImpl(
processState: null == processState ? _value.processState : processState // ignore: cast_nullable_to_non_nullable
as ProcessState,unitConsumed: null == unitConsumed ? _value.unitConsumed : unitConsumed // ignore: cast_nullable_to_non_nullable
as int,totalBill: null == totalBill ? _value.totalBill : totalBill // ignore: cast_nullable_to_non_nullable
as double,meters: null == meters ? _value._meters : meters // ignore: cast_nullable_to_non_nullable
as List<Meter>,considerMainMeterForRemainingUnits: null == considerMainMeterForRemainingUnits ? _value.considerMainMeterForRemainingUnits : considerMainMeterForRemainingUnits // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc


class _$SplitBillFormStateImpl  with DiagnosticableTreeMixin implements _SplitBillFormState {
  const _$SplitBillFormStateImpl({this.processState = const ProcessState.initial(), this.unitConsumed = 0, this.totalBill = 0.0, final  List<Meter> meters = const <Meter>[], this.considerMainMeterForRemainingUnits = true}): _meters = meters;

  

@override@JsonKey() final  ProcessState processState;
@override@JsonKey() final  int unitConsumed;
@override@JsonKey() final  double totalBill;
 final  List<Meter> _meters;
@override@JsonKey() List<Meter> get meters {
  if (_meters is EqualUnmodifiableListView) return _meters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_meters);
}

@override@JsonKey() final  bool considerMainMeterForRemainingUnits;

@override
String toString({ DiagnosticLevel minLevel = DiagnosticLevel.info }) {
  return 'SplitBillFormState(processState: $processState, unitConsumed: $unitConsumed, totalBill: $totalBill, meters: $meters, considerMainMeterForRemainingUnits: $considerMainMeterForRemainingUnits)';
}

@override
void debugFillProperties(DiagnosticPropertiesBuilder properties) {
  super.debugFillProperties(properties);
  properties
    ..add(DiagnosticsProperty('type', 'SplitBillFormState'))
    ..add(DiagnosticsProperty('processState', processState))..add(DiagnosticsProperty('unitConsumed', unitConsumed))..add(DiagnosticsProperty('totalBill', totalBill))..add(DiagnosticsProperty('meters', meters))..add(DiagnosticsProperty('considerMainMeterForRemainingUnits', considerMainMeterForRemainingUnits));
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$SplitBillFormStateImpl&&(identical(other.processState, processState) || other.processState == processState)&&(identical(other.unitConsumed, unitConsumed) || other.unitConsumed == unitConsumed)&&(identical(other.totalBill, totalBill) || other.totalBill == totalBill)&&const DeepCollectionEquality().equals(other._meters, _meters)&&(identical(other.considerMainMeterForRemainingUnits, considerMainMeterForRemainingUnits) || other.considerMainMeterForRemainingUnits == considerMainMeterForRemainingUnits));
}


@override
int get hashCode => Object.hash(runtimeType,processState,unitConsumed,totalBill,const DeepCollectionEquality().hash(_meters),considerMainMeterForRemainingUnits);

/// Create a copy of SplitBillFormState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$SplitBillFormStateImplCopyWith<_$SplitBillFormStateImpl> get copyWith => __$$SplitBillFormStateImplCopyWithImpl<_$SplitBillFormStateImpl>(this, _$identity);








}


abstract class _SplitBillFormState implements SplitBillFormState {
  const factory _SplitBillFormState({final  ProcessState processState, final  int unitConsumed, final  double totalBill, final  List<Meter> meters, final  bool considerMainMeterForRemainingUnits}) = _$SplitBillFormStateImpl;
  

  

@override ProcessState get processState;@override int get unitConsumed;@override double get totalBill;@override List<Meter> get meters;@override bool get considerMainMeterForRemainingUnits;
/// Create a copy of SplitBillFormState
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
_$$SplitBillFormStateImplCopyWith<_$SplitBillFormStateImpl> get copyWith => throw _privateConstructorUsedError;

}
